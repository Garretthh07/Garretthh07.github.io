---
layout: post
title: "趣谈网络协议"
description: "网络"
category: NetWork
tags: [Life]
---

{% include JB/setup %}


--------------------------

# 趣谈网络协议
**应用层**: `DNS`, `Http`, `Https` 所在的层为应用层.

**传输层**: 应用层封装成包之后会交给传输层（通过`Socket`编程来实现), `传输层`有两种协议：
* 无连接的`UDP`协议
* 面向连接的`TCP`协议
    * `TCP` 协议里有两个端口:
        * 浏览器监听的端口
        * 服务器监听的端口

> 操作系统往往通过端口来判断得到的包应该给哪个进程。

**网络层**: 网络层的协议是IP协议, 会有源`IP`地址和目标`IP`地址。
> 操作系统启动的时候会被 `DHCP` 协议配置`IP`地址, 以及默认网关的IP地址*(192.168.1.1)*.

**MAC层**: 操作系统通过 `ARP` 协议将`IP`地址发送给网关, 将 `IP`包交给下一层 `Mac层`.

* 网关往往是一个路由器, 路由器上维护一张路由表, 路由表由    相邻的路由器通过路由协议得到(常用的有 `OSPF` 和 `BGP`). 最后一个路由器知道这个网络包要去的地方，目标服务器会回复一个 `Mac地址`,  通过这个 `Mac地址`就可以找到目标服务器.

* 目标服务器发现 `Mac地址` 对上， 取下 `Mac头` 发送给操作系统`网络层`, 发现 `IP` 也对上, 取下`IP头`交给`传输层(TCP层)`，传输层对于收到的每个包，都会回复一个包说明收到。如果过一段时间还没到，发送端的`TCP层`会重新发送这个包。

* 当网络包平安到达 `TCP层` 之后, `TCP头`中有目标端口号. 通过 `RPC调用`(`RPC`框架有很多种，有基于`HTTP协议`的放在`HTTP`报文里的，有直接封装在`TCP`报文里的) 来告诉监听这个端口的服务器进程。

## ifconfig 命令
`Windows`上通过`ipconfig`, `Linux`上通过`ifconfig`命令或者`ip addr`命令 `来查看`IP`地址.
> `IP`地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号。

## 无类型域间选路(CIDR)
将`32`位的`IP`地址分为网络考和主机好两部分。类似于 `10.100.122.2/24`, 前`24`位表示网络号，后`8`位表示主机号.

## 公有IP地址和私有IP地址

![Ip分类]( http://7xpgi9.com1.z0.glb.clouddn.com/IPRange.png "IP分类")

> 公有`IP`地址有个组织统一分配。`192.168.0.x`是最常用的私有`IP`地址.`192.168.0.1`往往就是私有网络的出口地址，例如：家里的电脑连接 `Wi-Fi`, `Wi-Fi` 路由器的地址就是 `192.168.0.1`. `192.168.0.255` 是广播地址, 一旦发送这个地址， 整个`192.168.0`网络里的所有机器都能收到。

## ICMP与ping
`ping` 是基于`ICMP`(`Internet Control Message Protocol`, 互联网控制报文协议)协议工作的. `ICMP` 报文封装在 `IP` 包里面, 有很多的类型，不同类型有不同的代码。最常用的类型是主动请求为`8`, 主动请求的应答为`0`. 常用的`ping`就是查询报文，是一种主动请求，并且获得主动应答的`ICMP`协议.

对`ping`的主动请求，进行抓包称为 `ICMP ECHO REQUEST`.同理主动请求的回复，称为`ICMP ECHO REPLY`.比起原生的`ICMP`, 这里多了两个字段:
* 标识符
* 序号

### ICMP差错报文类型
* 终点不可达`3`, 具体的原因在代码中的标示
    * 网络不可达代码为`0`
    * 主机不可达代码为`1`
    * 协议不可达代码为`2`
    * 端口不可达代码为`3`
    * 需要进行分片但设置了不分片位代码为`4`
* 源抑制`4`
* 超时`11`
* 重定向`5`

### ping: 查询报文类型的使用
`主机A` 的`IP`地址是`192.168.1.1`, `主机B`的`IP`地址是`192.168.1.2`, 在同一子网， `主机A` 运行 `ping 192.168.1.2` 发生了啥？

> 源主机首先会构建一个`ICMP`请求数据包，`ICMP`数据包包含多个字段。最重要的以下两个：
* 类型字段: 对于请求数据包而言该字段为`8`
* 顺序号: 主要用于区分连续`ping`时发出的多个数据包,每发出一个请求数据包，顺序号会自动`+1`.

> 为了能计算往返时间`RTT`, 会在报文的数据部分插入发送时间。然后，由`ICMP`协议将数据包连同地址`192.168.1.2`一同交给`IP层`。`IP层`以`192.168.1.2`作为目的地址，本机`IP地址`作为源地址，加上一些其他控制信息，构建一个`IP数据包`。

### MAC头和IP头的细节
`MAC头`: 里先是`目标MAC地址`，然后是`源MAC地址`和一个协议类型。用来说明里面是`IP`协议。
`IP头`: 里面的版本号， 目前主流的是`IPv4`, 服务类型`TOS`,`TTL`和`8`标识协议.

任何一台机器上，当要访问另一个`IP地址`的时候，都会先判断，这个`目标IP地址`和当前机器的`IP地址`是否在同一网段，需要使用`CIDR`和子网掩码。
* 同一网段：直接将源地址和目标地址放入`IP头`中，然后通过`ARP`获得`MAC地址`，将`源MAC`和`目的MAC`放入`MAC头`中发出去。
* 不同网段: 需要发往默认网关`Gateway`, `Gateway`地址一定和`源IP地址`在同一网段。网关往往是一个路由器，是一个三层转发设备。但是把网关叫做路由器是不完全准确的 `路由器是一台设备，它有五个网口或网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址在相同的网段，每只手都是它握住哪个局域网的网关`

## HTTP协议
登陆 [www.163.com](http://www.163.com) 这个 `URL`(同一资源定位符), 浏览器会将 [www.163.com](http://www.163.com) 这个域名发送给 `DNS服务器`, 让他解析`IP地址`. `HTTP` 先通过三次握手建立 `TCP连接`. (目前使用的`HTTP协议`大部分都是`1.1`, 是默认开启 `Keep-Alive`, 建立的`TCP`连接，可以在多次请求中复用)。

`HTTP`的报文可以分为`3`大部分
* 请求行
请求行中`URL`就是[www.163.com](http://www.163.com)，版本为`HTTP 1.1`, **方法**有几种类型:
    * 访问网页来说，最常用的就是`GET`，服务器决定放回什么格式的内容(`JSON`字符串等)。
    * `POST` 需要主动告诉服务器一些信息。一般会放在正文里。正文可以用各种各样的格式。常见的格式也是`JSON`.
    * `PUT` 向指定资源位置上传最新内容. 但是，`HTTP`服务器往往不允许上传文件， 所以 `PUT` 和 `POST` 都变成要穿东西给服务器的方法。实际使用过程中， `POST` 往往用来创建一个资源，`PUT` 用来修改资源。
    * `DELETE` 用来删除资源。

* 首部
首部都是 `key` `value` 格式，通过冒号分隔。 里面保存一些非常重要的字段。例如:
    * `Accept-Charset` 表示客户端可以接收的字符集, 防止产生乱码。
    * `Content-Type` 表示正文的格式，我们使用 `POST` 请求， 如果正文是`JSON`这个值设置为`JSON`.
    * `Cache-control` 用来控制缓存
    * `If-Modified-Since`
* 正文实体

> `HTTP`请求发送: `HTTP协议` 是基于`TCP协议`的， 使用面向连接的方式发送请求， 通过 `stream` 二进制流的方式传给对方， 到了`TCP层`, 会把二进制流变成一个个报文段发送给服务器.

### HTTP返回的构建
`HTTP` 返回报文也有一定格式， 也是基于`HTTP 1.1`.
* 状态行
    * 状态码： 会反应`HTTP`请求的结果. `200`意味一切顺利; `404` 表示服务器无法响应这个请求。
    * 短语: 会大概说明一下原因。
* 首部
    * `Retry-After`表示告诉客户端应该在多长时间之后再尝试。`503`错误表示**服务器暂时不再和这个值配合使用**。
    * `Content-Type` 表示返回的是`HTML` 还是 `JSON`.

> `HTTP 1.1` 在应用层以纯文本的形式进行通信。 每次通信都要带完整的`HTTP头`, 不考虑`pipeline模式`的话， 每次的过程总是一来一回， 在**实时性**, **并发性**上都存在问题。 `HTTP 2.0` 会对 `HTTP头`进行一定的压缩， 将原来每次都要携带得的大量的 `key value` 在两端建立一个索引表, 对相同的头只发送索引表中的索引。

`Google` 的 `QUIC协议`, 从 `TCP` 切换到 `UDP`, 有如下几个特点:
* 自定义连接机制
> 不再以四元组(`源IP`,`源端口`,`目的IP`,`目的端口`)标识，而是以一个`64位`随机数作为`ID`来标识，而且`UDP`是无连接的，所以`IP`或`端口`变化时, 只要`ID`不变， 就不需要重新建立连接.

* 自定义重传机制
> `TCP` 为了保证可靠性，通过使用**序号**和**应答**机制类解决顺序和丢包问题。`QUIC`定义来一个`offset`的概念。`QUIC`是面向连接的，就像`TCP`一样是一个数据流, 发送的数据在这个数据流里有个偏移量`offset`, 可以通过 `offset` 查看数据发送到哪里， 只要`offset`包没有来就要重发。

* 无阻塞多路复用
> 有了自定义的连接和重传机制就可以解决`HTTP 2.0`的多路复用问题。

* 自定义流量控制
> `TCP`通过**滑动窗口协议**来实现流量控制。`QUIC`也通过`window_update`, 但是是适应自己的多路复用机制的， 不但在一个连接上控制窗口， 还在一个连接中的每个`steam`控制窗口。
