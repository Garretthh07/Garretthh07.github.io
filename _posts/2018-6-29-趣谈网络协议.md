---
layout: post
title: "趣谈网络协议"
description: "网络"
category: NetWork
tags: [Life]
---

{% include JB/setup %}


--------------------------


# 趣谈网络协议
**应用层**: `DNS`, `Http`, `Https` 所在的层为应用层.

**传输层**: 应用层封装成包之后会交给传输层（通过`Socket`编程来实现), `传输层`有两种协议：
* 无连接的`UDP`协议
* 面向连接的`TCP`协议
    * `TCP` 协议里有两个端口:
        * 浏览器监听的端口
        * 服务器监听的端口

> 操作系统往往通过端口来判断得到的包应该给哪个进程。

**网络层**: 网络层的协议是IP协议, 会有源`IP`地址和目标`IP`地址。
> 操作系统启动的时候会被 `DHCP` 协议配置`IP`地址, 以及默认网关的IP地址*(192.168.1.1)*.

**MAC层**: 操作系统通过 `ARP` 协议将`IP`地址发送给网关, 将 `IP`包交给下一层 `Mac层`.

* 网关往往是一个路由器, 路由器上维护一张路由表, 路由表由    相邻的路由器通过路由协议得到(常用的有 `OSPF` 和 `BGP`). 最后一个路由器知道这个网络包要去的地方，目标服务器会回复一个 `Mac地址`,  通过这个 `Mac地址`就可以找到目标服务器.

* 目标服务器发现 `Mac地址` 对上， 取下 `Mac头` 发送给操作系统`网络层`, 发现 `IP` 也对上, 取下`IP头`交给`传输层(TCP层)`，传输层对于收到的每个包，都会回复一个包说明收到。如果过一段时间还没到，发送端的`TCP层`会重新发送这个包。

* 当网络包平安到达 `TCP层` 之后, `TCP头`中有目标端口号. 通过 `RPC调用`(`RPC`框架有很多种，有基于`HTTP协议`的放在`HTTP`报文里的，有直接封装在`TCP`报文里的) 来告诉监听这个端口的服务器进程。

## ifconfig 命令
`Windows`上通过`ipconfig`, `Linux`上通过`ifconfig`命令或者`ip addr`命令 `来查看`IP`地址.
> `IP`地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号。

## 无类型域间选路(CIDR)
将`32`位的`IP`地址分为网络考和主机好两部分。类似于 `10.100.122.2/24`, 前`24`位表示网络号，后`8`位表示主机号.

## 公有IP地址和私有IP地址

![Ip分类]( http://7xpgi9.com1.z0.glb.clouddn.com/IPRange.png "IP分类")

> 公有`IP`地址有个组织统一分配。`192.168.0.x`是最常用的私有`IP`地址.`192.168.0.1`往往就是私有网络的出口地址，例如：家里的电脑连接 `Wi-Fi`, `Wi-Fi` 路由器的地址就是 `192.168.0.1`. `192.168.0.255` 是广播地址, 一旦发送这个地址， 整个`192.168.0`网络里的所有机器都能收到。

## ICMP与ping
`ping` 是基于`ICMP`(`Internet Control Message Protocol`, 互联网控制报文协议)协议工作的. `ICMP` 报文封装在 `IP` 包里面, 有很多的类型，不同类型有不同的代码。最常用的类型是主动请求为`8`, 主动请求的应答为`0`. 常用的`ping`就是查询报文，是一种主动请求，并且获得主动应答的`ICMP`协议.

对`ping`的主动请求，进行抓包称为 `ICMP ECHO REQUEST`.同理主动请求的回复，称为`ICMP ECHO REPLY`.比起原生的`ICMP`, 这里多了两个字段:
* 标识符
* 序号

### ICMP差错报文类型
* 终点不可达`3`, 具体的原因在代码中的标示
    * 网络不可达代码为`0`
    * 主机不可达代码为`1`
    * 协议不可达代码为`2`
    * 端口不可达代码为`3`
    * 需要进行分片但设置了不分片位代码为`4`
* 源抑制`4`
* 超时`11`
* 重定向`5`

### ping: 查询报文类型的使用
`主机A` 的`IP`地址是`192.168.1.1`, `主机B`的`IP`地址是`192.168.1.2`, 在同一子网， `主机A` 运行 `ping 192.168.1.2` 发生了啥？

> 源主机首先会构建一个`ICMP`请求数据包，`ICMP`数据包包含多个字段。最重要的以下两个：
* 类型字段: 对于请求数据包而言该字段为`8`
* 顺序号: 主要用于区分连续`ping`时发出的多个数据包,每发出一个请求数据包，顺序号会自动`+1`.

> 为了能计算往返时间`RTT`, 会在报文的数据部分插入发送时间。然后，由`ICMP`协议将数据包连同地址`192.168.1.2`一同交给`IP层`。`IP层`以`192.168.1.2`作为目的地址，本机`IP地址`作为源地址，加上一些其他控制信息，构建一个`IP数据包`。

### MAC头和IP头的细节
`MAC头`: 里先是`目标MAC地址`，然后是`源MAC地址`和一个协议类型。用来说明里面是`IP`协议。
`IP头`: 里面的版本号， 目前主流的是`IPv4`, 服务类型`TOS`,`TTL`和`8`标识协议.

任何一台机器上，当要访问另一个`IP地址`的时候，都会先判断，这个`目标IP地址`和当前机器的`IP地址`是否在同一网段，需要使用`CIDR`和子网掩码。
* 同一网段：直接将源地址和目标地址放入`IP头`中，然后通过`ARP`获得`MAC地址`，将`源MAC`和`目的MAC`放入`MAC头`中发出去。
* 不同网段: 需要发往默认网关`Gateway`, `Gateway`地址一定和`源IP地址`在同一网段。网关往往是一个路由器，是一个三层转发设备。但是把网关叫做路由器是不完全准确的 `路由器是一台设备，它有五个网口或网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址在相同的网段，每只手都是它握住哪个局域网的网关`

## UDP 协议
`TCP`是面向连接的， `UDP`是面向无连接的。在互通之前，面向连接的协议会先建立连接，例如：`TCP`会三次握手，而`UDP`不会。

**所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。**
* **`TCP`提供可靠交付**。通过`TCP`连接传输的数据，无差错，不丢失，不重复，并且按序到达。 **`UDP`继承了`IP包`的特性，不保证不丢失，不保证按顺序到达。**
* **`TCP`是面向字节流的**。发送的时候发的是一个流，没头没尾。`IP包`不是一个流，而是一个个`IP包`。之所以变成流，是`TCP`自己状态维护做的事情。**`UDP`继承了`IP`的特性，基于数据报的, 一个个的发，一个个的收。**
* **`TCP`可以有拥塞控制的**。它意识到包丢弃了或者网络环境不好，会根据清空调整自己的行为，看看是不是发快了， 要不要发慢点。 **UDP就不会，应用让我发，我就发。**
* **`TCP`其实是一个有状态服务**， **而`UDP`则是无状态服务**

### UDP包头
当我们发送的`UDP`包到达目标机器后，发现`MAC地址`匹配，于是取下来，将剩下的包传给处理`IP层`的代码。把`IP头`取消来，里面有个`8位`协议，会标示出数据到底是`TCP`还是`UDP`。

无论是`TCP`传数据还是`UDP`传数据，都要监听一个端口。`TCP` 还是 `UDP` 包头里有个端口号， 根据端口号，将数据交给相应的应用程序。

### UDP三大特点 
* **沟通简单**：不需要大量的数据结构，处理逻辑，包头字段。
* **轻信他人**：不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，它也可以传给任何人数据，甚至可以同时传给多人数据。
* **做事不懂权变**：不会根据网络的情况进行发包的拥塞控制，无论网络丢包成啥样，还是该怎么发就怎么发。

### UDP三大使用场景 
* **需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用**
* **不需要一对一沟通，建立连接，而是可以广播的应用**
* **需要处理速度快，时延低， 可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前**

### UDP的五个例子
* **网页或者`App`的访问**: `QUIC`(Quick UDP Internet Connections，快速`UDP`互联网连接啊)是`Google`提出的一种基于`UDP`改进的通信协议，目的是降低网络通信延迟，提供更好的用户互动体验。`QUIC`在应用层上，会自己实现快速连接建立，减少重传时延，自适应拥塞控制。
* **流媒体协议**: 直播协议多使用`RTMP`(也是基于`TCP`的), 由于`TCP`的限制，很多直播应用都基于`UDP`实现自己的视频传输协议。
* **实时游戏**: 要求较为严格，采用自定义的可靠`UDP`协议，自定义重传策略， 能够把丢包产生的延迟降到最低，尽量减少网路问题对游戏性造成的影响。
* **IoT物联网**：一方面物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护`TCP协议`代价太大；另一方面，物联网对实时性要求也很高，`Google`旗下的`Nest`建立`Thread Group`，推出了物联网通信协议 `Thread` , 就是基于`UDP协议的`
* **移动通行领域**: 在`4G`网络里，移动流量上网的数据面对的协议`GTP-U`是基于`UDP`的。因为移动网络协议比较复杂，而`GTP协议`本身就包含复杂的手机上线下线的通信协议。如果基于`TCP`, `TCP`的机制就显得非常多余。

## HTTP协议
登陆 [www.163.com](http://www.163.com) 这个 `URL`(同一资源定位符), 浏览器会将 [www.163.com](http://www.163.com) 这个域名发送给 `DNS服务器`, 让他解析`IP地址`. `HTTP` 先通过三次握手建立 `TCP连接`. (目前使用的`HTTP协议`大部分都是`1.1`, 是默认开启 `Keep-Alive`, 建立的`TCP`连接，可以在多次请求中复用)。

`HTTP`的报文可以分为`3`大部分
* 请求行
请求行中`URL`就是[www.163.com](http://www.163.com)，版本为`HTTP 1.1`, **方法**有几种类型:
    * 访问网页来说，最常用的就是`GET`，服务器决定放回什么格式的内容(`JSON`字符串等)。
    * `POST` 需要主动告诉服务器一些信息。一般会放在正文里。正文可以用各种各样的格式。常见的格式也是`JSON`.
    * `PUT` 向指定资源位置上传最新内容. 但是，`HTTP`服务器往往不允许上传文件， 所以 `PUT` 和 `POST` 都变成要穿东西给服务器的方法。实际使用过程中， `POST` 往往用来创建一个资源，`PUT` 用来修改资源。
    * `DELETE` 用来删除资源。

* 首部
首部都是 `key` `value` 格式，通过冒号分隔。 里面保存一些非常重要的字段。例如:
    * `Accept-Charset` 表示客户端可以接收的字符集, 防止产生乱码。
    * `Content-Type` 表示正文的格式，我们使用 `POST` 请求， 如果正文是`JSON`这个值设置为`JSON`.
    * `Cache-control` 用来控制缓存
    * `If-Modified-Since`
* 正文实体

> `HTTP`请求发送: `HTTP协议` 是基于`TCP协议`的， 使用面向连接的方式发送请求， 通过 `stream` 二进制流的方式传给对方， 到了`TCP层`, 会把二进制流变成一个个报文段发送给服务器.

### HTTP返回的构建
`HTTP` 返回报文也有一定格式， 也是基于`HTTP 1.1`.
* 状态行
    * 状态码： 会反应`HTTP`请求的结果. `200`意味一切顺利; `404` 表示服务器无法响应这个请求。
    * 短语: 会大概说明一下原因。
* 首部
    * `Retry-After`表示告诉客户端应该在多长时间之后再尝试。`503`错误表示**服务器暂时不再和这个值配合使用**。
    * `Content-Type` 表示返回的是`HTML` 还是 `JSON`.

> `HTTP 1.1` 在应用层以纯文本的形式进行通信。 每次通信都要带完整的`HTTP头`, 不考虑`pipeline模式`的话， 每次的过程总是一来一回， 在**实时性**, **并发性**上都存在问题。 `HTTP 2.0` 会对 `HTTP头`进行一定的压缩， 将原来每次都要携带得的大量的 `key value` 在两端建立一个索引表, 对相同的头只发送索引表中的索引。

`Google` 的 `QUIC协议`, 从 `TCP` 切换到 `UDP`, 有如下几个特点:
* 自定义连接机制
> 不再以四元组(`源IP`,`源端口`,`目的IP`,`目的端口`)标识，而是以一个`64位`随机数作为`ID`来标识，而且`UDP`是无连接的，所以`IP`或`端口`变化时, 只要`ID`不变， 就不需要重新建立连接.

* 自定义重传机制
> `TCP` 为了保证可靠性，通过使用**序号**和**应答**机制类解决顺序和丢包问题。`QUIC`定义来一个`offset`的概念。`QUIC`是面向连接的，就像`TCP`一样是一个数据流, 发送的数据在这个数据流里有个偏移量`offset`, 可以通过 `offset` 查看数据发送到哪里， 只要`offset`包没有来就要重发。

* 无阻塞多路复用
> 有了自定义的连接和重传机制就可以解决`HTTP 2.0`的多路复用问题。

* 自定义流量控制
> `TCP`通过**滑动窗口协议**来实现流量控制。`QUIC`也通过`window_update`, 但是是适应自己的多路复用机制的， 不但在一个连接上控制窗口， 还在一个连接中的每个`steam`控制窗口。

## DNS 协议
`DNS`服务器一定要设置成高可用，高并发和分布式的。树状层级结构：
* 根`DNS`服务器: 返回顶级域 `DNS` 服务器的 `IP` 地址
* 顶级域`DNS`服务器: 返回权威`DNS` 服务器的 `IP` 地址
* 权威`DNS`服务器: 返回相应主机的`IP`地址

为了提高`DNS`解析性能， 很多网络多会就近部署`DNS`缓存服务器。`DNS`的解析流程如下：
* 电脑客户端发送一个`DNS`请求，问 [http://www.163.com](http://www.163.com) 的 `IP` 是啥？并发给本地域名服务器(本地`DNS`: 如果通过`DHCP`配置，本地`DNS`由网络服务商`ISP`,如电信，移动等自动分配，通常在网络服务商的某个机房)
* 本地`DNS`收到来自客户端的请求。这台服务器上缓存一张域名与与之对应`IP地址`的大表格, 如果能找到，直接返回`IP地址`. 如果没有，本地`DNS`会去根域名服务器找， 根域名服务器是最高层次， 全球共有`13`套。它不直接用于域名解析，但能知名一条道路。
* 根`DNS`收到来自本地`DNS`的请求，发现后缀是`.com`, 发现是由`.com`区域管理， 获得顶级域名服务器地址
* 本地`DNS`转向问顶级域名服务器，顶级域名服务器就是比如`.com`, `.net`, `.org` 这些一级域名，它负责管理二级域名， 比如`163.com`。
* 从顶级域名服务器获取[http://www.163.com](http://www.163.com)区域的权威`DNS`服务器地址
* 本地`DNS`转向权威`DNS`服务器，`163.com` 的权威`DNS`服务器是域名解析结果的源出处
* 权威`DNS`服务器查询后将相应的`IP地址` `X.X.X.X`告诉本地`DNS`.
* 本地`DNS`再将`IP地址`返回客户端，客户端和目标建立连接.

### 负载均衡
站在客户端的角度， 上面的过程是一次`DNS递归查询过程`。这个过程中，`DNS` 除了可以通过名称映射为`IP地址`，还可以实现**负载均衡**.

`DNS`首先可以做**内部负载均衡** , 还可以实现**全局负载均衡**。

> **DNS访问数据中心中对象存储上的静态资源**：假设全国有多个数据中心，托管在多个运营商， 每个数据中心有三个可用区(`Available Zone`)。对象存储通过跨可用区部署，实现高可用性。 在每个数据中心中， 都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器。
* 当一个客户端要访问`object.yourcompany.com`时，需要将域名转换为`IP地址`进行访问，所以要请求`本地DNS解析器`
* `本地DNS解析器`先查看本地的缓存是否有这个记录。如果有直接使用
* 如果本地无缓存，则需要请求`本地DNS服务器`
* `本地DNS服务器`一般部署在你的数据中心或者你所在运营商的网络中，`本地DNS服务器`也需要看本地是否有缓存， 如果有则返回 
* 如果本地没有，`本地DNS` 才需要递归从`根DNS服务器`查到`.com`的顶级域名服务器，最终查到`yourcompany.com`的`权威DNS服务器`给`本地DNS服务器`，`权威DNS服务器`会返回真实要访问的`IP地址`

