---
layout: post
title: "Unity Shader"
description: "Unity Shader"
category: Unity Shader
tags: [Life]
---

{% include JB/setup %}


--------------------------

## Unity Shader

`Shader`, 即着色器，与之关系非常紧密的就是渲染流水线。渲染流水线的最终目的在于生成或渲染一张二维纹理，就是我们电脑上看到的所有效果。它的输入是一个虚拟摄像机，一些光源，一些`Shader`以及纹理等。

`Shader`仅仅是渲染流水线中的一个环节。渲染流水线的工作任务在于由一个三维场景出发，生成(或者说渲染)一张二维图像。换句话说，计算机需要从一系列的顶点数据，纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由`CPU`和`GPU`共同完成的。

![3阶段](http://7xpgi9.com1.z0.glb.clouddn.com/UnityShader_1.JPG "3阶段")

`<Real-Time Rendering ,Third Edition>`书中将渲染流程分为`3`个阶段：**应用阶段(Application Stage)**, **几何阶段(Geometry Stage)**, **光栅化阶段(Rasterizer Stage)**。每个阶段本身通常也是一个流水线系统，即包含了子流水线阶段：

* **应用阶段**
由应用主导，通常由`CPU`负责实现，开发者具有这个阶段的绝对控制权。这个阶段开发者由`3`个任务：`1`. 需要准备好场景数据，例如摄像机的位置，视锥体，场景中包含那些模型，使用那些光源等；`2`. 为了提高渲染性能，往往需要做一个粗粒度剔除(`culling`)工作，把那些不可见的物体剔除出去，就不用移交给**几何阶段**处理；`3`. 需要设置每个模型的渲染状态，这些渲染状态包括但不限于它使用的材质(漫反射颜色，高光反射颜色)，使用的纹理，使用的`Shader`等。这一阶段最重要的是输出渲染所需的几何信息，即**渲染图元(rendering primitives)**。通俗来讲，渲染图元可以是**点**，**线**, **三角面**等。这些渲染图元会被传递给下一个阶段-**几何阶段**

* **几何阶段**
**几何阶段**用于处理所有和我们要绘制的几何相关的事情。例如，决定需要绘制的图元是什么，怎样绘制它们，在哪里绘制它们。该阶段通常在`GPU`上进行。**几何阶段**负责和每个渲染图元打交道，进行逐顶点，逐多边形的操作。该阶段可以进一步分成更小的流水线阶段。**几何阶段**的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后，该阶段会输出屏幕空间的二维顶点坐标，每个顶点对应的深度值，着色等相关信息，并传递给下一阶段。

* **光栅化阶段**
该阶段会使用上阶段传递的数据来生成屏幕上的像素，并渲染除最终的图像。该阶段也是在`GPU`上运行的，光栅化的任务主要是决定每个渲染图元中的那些像素应该被绘制在屏幕上。它需要对上一阶段得到的逐顶点数据(例如纹理坐标，顶点颜色等)进行插值，然周再进行像素处理。**光栅化阶段**也可以分成更小的流水线阶段。

> 上面的`3`个流水线阶段和`GPU`流水线阶段不同，这里的流水线都是概念流水线，是我们为来给一个渲染流程进行基本功能划分而提出来的。`GPU`流水线才是硬件真正用于实现上述概念的流水线。

## CPU 和 GPU 之间通信
渲染流水线的起点是`CPU`,即应用阶段。应用阶段大致可分为如下`3`个阶段：

![2](http://7xpgi9.com1.z0.glb.clouddn.com/UnityShader_2.JPG "2")

* **把数据加载到显存中**
所有渲染所需的数据都需要从硬盘(`Hard Disk Drive, HDD`)中加载到系统内存(`Random Access Memory, RAM`)中。然后，网格和纹理等数据又被加载到显卡上的存储空间-显存(`Video Random Access Memory, VRAM`)中。这是因为，显卡对于显存的访问速度更快，而且大多数显卡对于`RAM`没有直接访问权。需要注意的是，真实渲染中需要加载到显存中的数据往往比图中所示复杂的多。例如，顶点的位置信息，法线方向，顶点颜色，纹理坐标等。当把数据加载到显存中后，`RAM`中的数据就可以移除了。但对于一些数据来说，`CPU`仍然需要访问它们(例如，我们希望`CPU`可以访问网格数据来进行碰撞检测)，那么我们可能就不希望这些数据被移除，因为从硬盘加载到`RAM`的过程是十分耗时的。之后，开发者还需要通过`CPU`来设置渲染状态，从而指导`GPU`如何进行渲染工作。

![3](http://7xpgi9.com1.z0.glb.clouddn.com/UnityShader_3.JPG "3")

* **设置渲染状态**
**渲染状态**定义来场景中的网格是怎样被渲染的。例如，使用哪个顶点着色器(`Vertex Shader`)/片元着色器(`Fragment Shader`), 光源属性， 材质等。如果我们没有更改渲染状态，那所有的网格都将使用同一种渲染状态。上图显示了当使用同一种渲染状态时，渲染的`3`个不同网格的结果。准备好所哟工作后，`CPU`就需要调用一个渲染命令（`Draw Call`）来告诉`GPU`。

![4](http://7xpgi9.com1.z0.glb.clouddn.com/UnityShader_4.JPG "4")

* **调用`Draw Call`**
`Draw Call`就是一个命令，它的发起方是`CPU`, 接收方是`GPU`。这个命令仅仅会指向一个需要被渲染的图元(`primitives`)列表，而不会再包含任何材质信息-这是因为我们已经在上一阶段中完成了。当给定一个`Draw Call`时，`GPU`就会根据渲染状态(例如材质，纹理，着色器等)和所有输入的顶点数据来进行计算， 最终输出成屏幕上显示的那些像素。这个过程就是`GPU`流水线。
