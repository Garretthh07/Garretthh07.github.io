---
layout: post
title: "Python"
description: "Python"
category: Python
tags: [Life]
---

{% include JB/setup %}


--------------------------

## Python
### range和xrange区别
* `range`: `range([start,]stop[,step])`根据`start`与`stop`指定的范围以及`step`设定的步长生成一个序列。
* `xrange`: 用法与`range`完全相同，所不同的是生成的不是一个数组，而是`一个生成器生成器`

>  要生成很大数字序列的时候，使用`xrange`比`range`性能优很多，因为不需要一上来就开辟一块很大的内存空间。

### 字典items和iteritems区别
都是`python`字典的内建函数，分别会返回`python列表`和迭代器
* `items`: 可以将字典中的所有项，以列表方式返回。因为字典是无序的，所有用items方法返回字典的所有项，也是没有顺序的。`items()`方法将字典中的每项分别作为元组，添加到一个列表中，形成一个新的列表容器。
* `iteritems`: 与`items`方法相比作用大致相同，只是返回值不是列表而是一个迭代器.
`dic.iteritems()`方法在需要迭代结果时使用最合适，而且它的工作效率非常高。

### enumerate()函数
`enumerate()`函数用于将一个可遍历的数据对象(如列表，元祖或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在`for`循环中。

> enumerate(sequence, [start=0])
* `sequenece`： 一个序列，迭代器或其他支持迭代的对象。
* `start`: 下标起始位置
* `返回值`: 返回`enumerate(枚举)`对象

```python
>>>> seasons = ['Spring','Summer','Fall','Winter']
>>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>>> list(enumerate(seasons, 1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')   ]
```

以下原文： [https://eastlakeside.gitbooks.io/interpy-zh/content/Generators/Generators.html](https://eastlakeside.gitbooks.io/interpy-zh/content/Generators/Generators.html)
### *args 和 **kwargs
* `*args`
> `*args` 和 `**kwargs`主要用于函数定义。可以将不定数量的参数传递给一个函数。

```python``
def test_var_args(f_arg, *argv):
    print("first normal arg:", f_arg)
    for arg in argv:
        print("another arg through *argv:", arg)

test_var_args('yasoob', 'python', 'eggs', 'test')
## Output:
('first normal arg:', 'yasoob')
('another arg through *argv:', 'python')
('another arg through *argv:', 'eggs')
('another arg through *argv:', 'test')
```
* `**kwargs`
> `**kwargs` 允许将不定长度的**键值对**，作为参数传递给一个函数。如果想要一个函数里处理**带名字的参数**, 应该使用`**kwargs`.

```python
def greet_me(**kwargs):
    for key,value in kwargs.items():
        print("{0} == {1}".format(key, value))

greet_me(name="yasoob")
## Output:
name == yasoob
```
> `标准参数与 *args, **kwargs 在使用时的顺序`: some_func(fargs, *args, **kwargs)

### 生成器(Generators) 
根据维基百科，迭代器是一个让程序员可以遍历一个容器(特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。迭代器可以概括为:
* **可迭代对象(`Iterable`)**：`Python`中任意对象，只要它定义了可返回一个迭代器`__iter__`方法，或者定义可以支持下标索引的`__getitem__`方法, 那么它就是一个可迭代对象。
* **迭代器(`Iterator`)**: 任意对象，只要定义`next`(Pthon2)或者`__next__`方法，它就是一个迭代器。
* **迭代(`Iteration`)**:从某个地方(比如一个列表)取出一个元素的过程。当我们使用循环来遍历某个东西时，这个过程本身就叫迭代。
> **生成器**也是一种迭代器，但是只能对其迭代一次。这是因为它并没有把所有的值存在内存中，而是在运行时生成值。通过遍历来使用它们，要么用`for`循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它并不返回值，而是`yield`一个值.
```python
def fibon(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

for x in fibon(1000000):
    print(x)
```
> 这种方式， 可以不用担心它会使用大量资源。`Python`中`str`对象不是一个迭代器，但是是**可迭代对象**, 内置函数 `iter` 会根据一个可迭代对象返回一个迭代器对象。
```python
my_string = "Yasoob"
my_iter = iter(my_string)
print(next(my_iter))
# Output: 'Y'
```

### Map, Filter 和 Reduce
**Map**
`Map`会将一个函数映射到一个输入列表的所有元素上。
```python
map(function_to_apply, list_of_inputs)

例子1:
items = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, items))

例子2:
def multiply(x):
    return (x*x)

def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = map(lambda x: x(i), funcs)
    print(list(value)) 
    # 加`list`转换是为了python2/3兼容 
    # python2中map直接返回列表， python3中返回迭代器
```

**Filter**
`filter` 过滤列表中的元素，并且返回一个由所有**符合要求**(函数映射到该元素时返回值为`True`)的元素所构成的列表。
> **filter(function, iterable)**
* `function`: 判断函数
* `iterable`: 可迭代对象

```python
number_list = range(-5, 5)
less_than_zero = filter(lambda x: (x < 0), number_list)
print(list(less_than_zero))
```
**Reduce**
当需要对一个列表进行一些计算并返回结果时， `reduce` 是个非常有用的函数。
> **reduce(function, iterable[, initializer])**
* `function`: 函数有两个参数
* `iterable`: 可迭代对象
* `initializer`: 可选，开始参数

```python
from functools import reduce

product = reduce((lambda x, y: x*y), [1, 2, 3, 4])

# Output: 24
```

### set(集合)数据结构
`set`(集合)是一个非常有用的数据结构。它与列表(`list`)的行为类似，区别在于`set`不能包含重复的值。假设要检查列表中是否包含重复元素，可以有两种方法:
 
**方式一**:

     some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']
    
    duplicates = []
    for value in some_list:
        if some_list.count(value) > 1:
            if value not in duplicates:
                duplicates.append(value)
    
    print(duplicates)
    # Output: ['b', 'n']
    

**方式二**:

    some_list = ['a', 'b', 'c', 'b', 'd', 'm', 'n', 'n']
    
    duplicates = set([x for x in some_list if some_list.count(x) > 1])
    
    print(duplicates)
    
    #Output: set(['b', 'n'])
    
### set交集 
```python
valid = set(['yellow', 'red', 'blue', 'green', 'black'])
input_set = set(['red', 'brown'])
print(input_set.intersection(valid))

#Output: set(['red'])
```
### set差集 
```python
# -*- coding: UTF-8 -*-
#!usr/bin/env python

valid = set(['yellow', 'red', 'blue', 'green', 'black'])
input_set = set(['red', 'brown'])
print(input_set.difference(valid))

#Output: set(['brown'])

# 也可以用`{}`符号来创建集合

a_set = {'red', 'blue', 'green'}
print(type(a_set))
## Output: <type 'set'>
```

## 三元运算符
三元运算符在`Python`里通常被称为条件表达式，这些表达式基于`True False`的条件判断，在`Python 2.4`以上才有三元操作。

```python
condition_is_true if condition else condition_is_false

is_fat = True
state = "fat" is_fat else "not fat"
```

## 装饰器
**装饰器(Decorators)**是`Python`的一个重要部分。简单的说：他们是修改其他函数的功能函数，他们有助于让我们的代码更简短。

* `Python`中一切皆对象
```python
def hi(name="yasoob"):
    return "hi " + name

print(hi())
#Output: hi yasoob

greet = hi

print(greet())
#Output: hi yasoob

del hi
print(hi())
#Output: NameError

print(greet())
#Output: hi yasoob
```

* 在函数中定义函数
```python
def hi(name="yasoob"):
    print("now you are inside the hi() function")

    def greet():
        return "now you are in the greet() function"

    def welcome():
        return "now you are in the welcome() function"

    print(greet())
    print(welcome())
    print("now you are back in the hi() function")

hi()

#Output: now you are inside the hi() function
#        now you are in the greet() function
#        now you are in the welcome() function
#        now you are back in the hi() function
```

* 从函数中返回函数
```python
def hi(name="yasoob"):

    def greet():
        return "now you are in the greet() function"

    def welcome():
        return "now you are in the welcome() function"

    if name == "yasoob":
        return greet
    else:
        return welcome
a = hi()
print(a)
#Output: <function greet at 0x10a64e050>

print(a())
#Output: now you are in the greet() function
```

* 将函数作为参数传给另一个函数
```python
def hi():
    return "hi yasoob!"

def doSomethingBeforeHi(func):
    print("I am doing some boring work before executing hi()")
    print(func())

doSomethingBeforeHi(hi)

#Output: I am doing some boring work before executing hi()
#        hi yasoob!
```
### 第一个装饰器
```python
def a_new_decorator(a_func):
    def wrapTheFUnction():
        print("I am doing some boring work before executing a_func()")

        a_func()

        print("I am doing some boring work after executing a_func()")

    return wrapTheFUnction

def a_function_requiring_decoration():
    print("I am the function which needs some decoration to remove my foul smell")

a_function_requiring_decoration()
#Output: I am the function which needs some decoration to remove my foul smell

a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
# now a_function_requiring_decoration is wrapped by wrapTheFUnction()

a_function_requiring_decoration()
#Output:  I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()
```

> 这个就是`Python`中装饰器做的事，它们封装一个函数，并且用这样或那样的方式来修改它的行为。`@` 符号只是用一个简短的方式来生成一个被装饰的函数。可以修改成`@`来运行之前的代码:

```python
def a_new_decorator(a_func):
    def wrapTheFUnction():
        print("I am doing some boring work before executing a_func()")

        a_func()

        print("I am doing some boring work after executing a_func()")

    return wrapTheFUnction

@a_new_decorator
def a_function_requiring_decoration():
    """Hey you! Decorate me!"""
    print("I am the function which needs some decoration to remove my foul smell")

a_function_requiring_decoration()
#Output:  I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()

#the @a_new_decorator is just a short way of saying:
a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)
```

> 但是我们运行如下代码会存在一个问题:

```python
print(a_function_requiring_decoration.__name__)
#Output: wrapTheFunction
```
> 这不是我们想要的! `Output`输出应该是`a_function_requiring_decoration`。 这里的函数被 `wrapTheFunction` 替代了。 它重写了我们函数的名字和注释文档(`docstring`)。幸运的是`Python`提供给我们一个简单的函数来解决这个问题， 那就是 `functools.wraps`:

```python
from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")

        a_func()

        print("I am doing some boring work after executing a_func()")

    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    """Hey you! Decorate me!"""
    print("I am the function which needs some decoration to remove my foul smell")


print(a_function_requiring_decoration.__name__, a_function_requiring_decoration.__doc__)
#Output: ('a_function_requiring_decoration', 'Hey you! Decorate me!')
```

**装饰器有一些使用场景**：

* 蓝本规范

```python
from functools import wraps

def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not can_run:
            return "Function will not run"

        return f(*args, **kwargs)

    return decorated

@decorator_name
def func():
    return "Function is running"

can_run = True
print(func())
#Output: Function is running

can_run = False
print(func())
#Output: Function will not run
```

> `@wraps`接受一个函数来进行装饰，并加入复制**函数名称**，**注释文档**，**参数列表**等功能。这可以让我们在装饰器里访问在装饰之前函数的属性。

* 授权(Authorization)
装饰器能有助于检查某人是否被授权去使用一个`web`应用的端点(endpoint)。它们被大量使用于`Flask`和`Django Web`框架中。

```python
from functools import wraps

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if (not auth) or (not check_auth(auth.username, auth.password)):
            authenticate()

        return f(*args, **kwargs)

    return decorated
```

* 日志(Loggin)

```python
from functools import wraps

def logit(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print(func.__name__ + " war called")
        return func(*args, **kwargs)

    return with_logging

@logit
def addition_func(x):
    """Do some math."""
    return x + x

print(addition_func(4))
#Output: addition_func war called
#        8
```

### 带参数的装饰器
`@wraps`也是一个装饰器，接收一个参数，就像任何普通函数能做的那样。 **为什么我们不也那样做？** 这是因为，当使用 `@my_decorator` 语法时，是在应用一个以单个函数作为参数的一个包裹函数。`Python`中每个东西都是一个对象，我们可以编写一个能返回一个包裹函数的函数。

```python
from functools import wraps

def logit(logfile='out.log'):
    def loggine_decorator(func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " was called"
            print(log_string)

            with open(logfile, 'a') as opened_file:
                opened_file.write(log_string + ' \n')

            return func(*args, **kwargs)
        return wrapped_function
    return loggine_decorator

@logit()
def myfunc1():
    pass

myfunc1()

@logit(logfile='func2.log')
def myfunc2():
    pass

myfunc2()
```

### 装饰器类
~~现在我们有了能用于正式环境的`logit`装饰器，但我们应用的某些部分还是比较脆弱的，异常也许是需要更紧急关注的事情。比如只想打日志到一个文件，而有时想把问题发送一个 `email`, 同时也保留日志，留个记录。这是一个使用继承的场景，幸运的是，类也可以用来构建装饰器。我们以一个类而不是一个函数来重新构建`logit`。~~(`Python2.7` 没有效果, 有待进一步确认)

```python
# -*- coding: UTF-8 -*-
#!usr/bin/env python

from functools import wraps

class logit(object):
    def __init__(self, logfile='out.log'):
        self.logfile = logfile

    def __call__(self, func):
        @wraps(func)
        def wrapped_function(*args, **kwargs):
            log_string = func.__name__ + " war called"
            print(log_string)

            with open(self.logfile, 'a') as opened_file:
                opened_file.wirte(log_string, ' \n')

            self.notify()
            return func(*args, **kwargs)
        return wrapped_function

    def notify(self):
        pass

class email_logit(logit):
    '''
    一个logit的实现版本， 可以在函数调用时发送email给管理员
    '''
    def __init__(self, email='admin@myproject.com', *args, **kwargs):
        self.email = email
        super(email_logit, self).__init__(*args, **kwargs)

    def notify(self):
        pass

@email_logit()
def myfunc1():
    pass
```
