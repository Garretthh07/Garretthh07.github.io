---
layout: post
title: "Python"
description: "Python"
category: Python
tags: [Life]
---

{% include JB/setup %}


--------------------------

## Python
### range和xrange区别
* `range`: `range([start,]stop[,step])`根据`start`与`stop`指定的范围以及`step`设定的步长生成一个序列。
* `xrange`: 用法与`range`完全相同，所不同的是生成的不是一个数组，而是`一个生成器生成器`

>  要生成很大数字序列的时候，使用`xrange`比`range`性能优很多，因为不需要一上来就开辟一块很大的内存空间。

### 字典items和iteritems区别
都是`python`字典的内建函数，分别会返回`python列表`和迭代器
* `items`: 可以将字典中的所有项，以列表方式返回。因为字典是无序的，所有用items方法返回字典的所有项，也是没有顺序的。`items()`方法将字典中的每项分别作为元组，添加到一个列表中，形成一个新的列表容器。
* `iteritems`: 与`items`方法相比作用大致相同，只是返回值不是列表而是一个迭代器.
`dic.iteritems()`方法在需要迭代结果时使用最合适，而且它的工作效率非常高。

### enumerate()函数
`enumerate()`函数用于将一个可遍历的数据对象(如列表，元祖或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在`for`循环中。

> enumerate(sequence, [start=0])
* `sequenece`： 一个序列，迭代器或其他支持迭代的对象。
* `start`: 下标起始位置
* `返回值`: 返回`enumerate(枚举)`对象

```python
>>>> seasons = ['Spring','Summer','Fall','Winter']
>>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>>> list(enumerate(seasons, 1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

以下原文： [https://eastlakeside.gitbooks.io/interpy-zh/content/Generators/Generators.html](https://eastlakeside.gitbooks.io/interpy-zh/content/Generators/Generators.html)
### 生成器(Generators) 
根据维基百科，迭代器是一个让程序员可以遍历一个容器(特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。迭代器可以概括为:
* **可迭代对象(`Iterable`)**：`Python`中任意对象，只要它定义了可返回一个迭代器`__iter__`方法，或者定义可以支持下标索引的`__getitem__`方法, 那么它就是一个可迭代对象。
* **迭代器(`Iterator`)**: 任意对象，只要定义`next`(Pthon2)或者`__next__`方法，它就是一个迭代器。
* **迭代(`Iteration`)**:从某个地方(比如一个列表)取出一个元素的过程。当我们使用循环来遍历某个东西时，这个过程本身就叫迭代。
> **生成器**也是一种迭代器，但是只能对其迭代一次。这是因为它并没有把所有的值存在内存中，而是在运行时生成值。通过遍历来使用它们，要么用`for`循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它并不返回值，而是`yield`一个值.
```python
def fibon(n):
    a = b = 1
    for i in range(n):
        yield a
        a, b = b, a + b

for x in fibon(1000000):
    print(x)
```
> 这种方式， 可以不用担心它会使用大量资源。`Python`中`str`对象不是一个迭代器，但是是**可迭代对象**, 内置函数 `iter` 会根据一个可迭代对象返回一个迭代器对象。
```python
my_string = "Yasoob"
my_iter = iter(my_string)
print(next(my_iter))
# Output: 'Y'
```

### Map, Filter 和 Reduce
**Map**
`Map`会将一个函数映射到一个输入列表的所有元素上。
```python
map(function_to_apply, list_of_inputs)

例子1:
items = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, items))

例子2:
def multiply(x):
    return (x*x)

def add(x):
    return (x+x)

funcs = [multiply, add]
for i in range(5):
    value = map(lambda x: x(i), funcs)
    print(list(value)) 
    # 加`list`转换是为了python2/3兼容 
    # python2中map直接返回列表， python3中返回迭代器
```

**Filter**
`filter` 过滤列表中的元素，并且返回一个由所有**符合要求**(函数映射到该元素时返回值为`True`)的元素所构成的列表。
> **filter(function, iterable)**
* `function`: 判断函数
* `iterable`: 可迭代对象

```python
number_list = range(-5, 5)
less_than_zero = filter(lambda x: (x < 0), number_list)
print(list(less_than_zero))
```
**Reduce**
当需要对一个列表进行一些计算并返回结果时， `reduce` 是个非常有用的函数。
> **reduce(function, iterable[, initializer])**
* `function`: 函数有两个参数
* `iterable`: 可迭代对象
* `initializer`: 可选，开始参数

```python
from functools import reduce

product = reduce((lambda x, y: x*y), [1, 2, 3, 4])

# Output: 24
```
